// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com.opensource.svga.video.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ComOpensourceSvgaVideo.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ComOpensourceSvgaVideoRoot

@implementation ComOpensourceSvgaVideoRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ComOpensourceSvgaVideoRoot_FileDescriptor

static GPBFileDescriptor *ComOpensourceSvgaVideoRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.opensource.svga"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MovieParams

@implementation MovieParams

@dynamic viewBoxWidth;
@dynamic viewBoxHeight;
@dynamic fps;
@dynamic frames;

typedef struct MovieParams__storage_ {
  uint32_t _has_storage_[1];
  float viewBoxWidth;
  float viewBoxHeight;
  int32_t fps;
  int32_t frames;
} MovieParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "viewBoxWidth",
        .dataTypeSpecific.className = NULL,
        .number = MovieParams_FieldNumber_ViewBoxWidth,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MovieParams__storage_, viewBoxWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "viewBoxHeight",
        .dataTypeSpecific.className = NULL,
        .number = MovieParams_FieldNumber_ViewBoxHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MovieParams__storage_, viewBoxHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "fps",
        .dataTypeSpecific.className = NULL,
        .number = MovieParams_FieldNumber_Fps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MovieParams__storage_, fps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "frames",
        .dataTypeSpecific.className = NULL,
        .number = MovieParams_FieldNumber_Frames,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MovieParams__storage_, frames),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MovieParams class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MovieParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpriteEntity

@implementation SpriteEntity

@dynamic imageKey;
@dynamic framesArray, framesArray_Count;

typedef struct SpriteEntity__storage_ {
  uint32_t _has_storage_[1];
  NSString *imageKey;
  NSMutableArray *framesArray;
} SpriteEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageKey",
        .dataTypeSpecific.className = NULL,
        .number = SpriteEntity_FieldNumber_ImageKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpriteEntity__storage_, imageKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "framesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FrameEntity),
        .number = SpriteEntity_FieldNumber_FramesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SpriteEntity__storage_, framesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpriteEntity class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpriteEntity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Layout

@implementation Layout

@dynamic x;
@dynamic y;
@dynamic width;
@dynamic height;

typedef struct Layout__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float width;
  float height;
} Layout__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = Layout_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Layout__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = Layout_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Layout__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = Layout_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Layout__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = Layout_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Layout__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Layout class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Layout__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transform

@implementation Transform

@dynamic a;
@dynamic b;
@dynamic c;
@dynamic d;
@dynamic tx;
@dynamic ty;

typedef struct Transform__storage_ {
  uint32_t _has_storage_[1];
  float a;
  float b;
  float c;
  float d;
  float tx;
  float ty;
} Transform__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "a",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_A,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transform__storage_, a),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "b",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_B,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transform__storage_, b),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "c",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_C,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transform__storage_, c),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "d",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_D,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transform__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tx",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_Tx,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transform__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "ty",
        .dataTypeSpecific.className = NULL,
        .number = Transform_FieldNumber_Ty,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transform__storage_, ty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transform class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transform__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShapeEntity

@implementation ShapeEntity

@dynamic argsOneOfCase;
@dynamic type;
@dynamic shape;
@dynamic rect;
@dynamic ellipse;
@dynamic hasStyles, styles;
@dynamic hasTransform, transform;

typedef struct ShapeEntity__storage_ {
  uint32_t _has_storage_[2];
  ShapeEntity_ShapeType type;
  ShapeEntity_ShapeArgs *shape;
  ShapeEntity_RectArgs *rect;
  ShapeEntity_EllipseArgs *ellipse;
  ShapeEntity_ShapeStyle *styles;
  Transform *transform;
} ShapeEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ShapeEntity_ShapeType_EnumDescriptor,
        .number = ShapeEntity_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "shape",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_ShapeArgs),
        .number = ShapeEntity_FieldNumber_Shape,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, shape),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_RectArgs),
        .number = ShapeEntity_FieldNumber_Rect,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ellipse",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_EllipseArgs),
        .number = ShapeEntity_FieldNumber_Ellipse,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, ellipse),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "styles",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_ShapeStyle),
        .number = ShapeEntity_FieldNumber_Styles,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, styles),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transform",
        .dataTypeSpecific.className = GPBStringifySymbol(Transform),
        .number = ShapeEntity_FieldNumber_Transform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeEntity__storage_, transform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "args",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ShapeEntity_Type_RawValue(ShapeEntity *message) {
  GPBDescriptor *descriptor = [ShapeEntity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetShapeEntity_Type_RawValue(ShapeEntity *message, int32_t value) {
  GPBDescriptor *descriptor = [ShapeEntity descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void ShapeEntity_ClearArgsOneOfCase(ShapeEntity *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Enum ShapeEntity_ShapeType

GPBEnumDescriptor *ShapeEntity_ShapeType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Shape\000Rect\000Ellipse\000Keep\000";
    static const int32_t values[] = {
        ShapeEntity_ShapeType_Shape,
        ShapeEntity_ShapeType_Rect,
        ShapeEntity_ShapeType_Ellipse,
        ShapeEntity_ShapeType_Keep,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShapeEntity_ShapeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShapeEntity_ShapeType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShapeEntity_ShapeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShapeEntity_ShapeType_Shape:
    case ShapeEntity_ShapeType_Rect:
    case ShapeEntity_ShapeType_Ellipse:
    case ShapeEntity_ShapeType_Keep:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ShapeEntity_ShapeArgs

@implementation ShapeEntity_ShapeArgs

@dynamic d;

typedef struct ShapeEntity_ShapeArgs__storage_ {
  uint32_t _has_storage_[1];
  NSString *d;
} ShapeEntity_ShapeArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "d",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeArgs_FieldNumber_D,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeArgs__storage_, d),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity_ShapeArgs class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity_ShapeArgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ShapeEntity)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShapeEntity_RectArgs

@implementation ShapeEntity_RectArgs

@dynamic x;
@dynamic y;
@dynamic width;
@dynamic height;
@dynamic cornerRadius;

typedef struct ShapeEntity_RectArgs__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float width;
  float height;
  float cornerRadius;
} ShapeEntity_RectArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_RectArgs_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity_RectArgs__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_RectArgs_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShapeEntity_RectArgs__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_RectArgs_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeEntity_RectArgs__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_RectArgs_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShapeEntity_RectArgs__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "cornerRadius",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_RectArgs_FieldNumber_CornerRadius,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShapeEntity_RectArgs__storage_, cornerRadius),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity_RectArgs class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity_RectArgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ShapeEntity)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShapeEntity_EllipseArgs

@implementation ShapeEntity_EllipseArgs

@dynamic x;
@dynamic y;
@dynamic radiusX;
@dynamic radiusY;

typedef struct ShapeEntity_EllipseArgs__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float radiusX;
  float radiusY;
} ShapeEntity_EllipseArgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_EllipseArgs_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity_EllipseArgs__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_EllipseArgs_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShapeEntity_EllipseArgs__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "radiusX",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_EllipseArgs_FieldNumber_RadiusX,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeEntity_EllipseArgs__storage_, radiusX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "radiusY",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_EllipseArgs_FieldNumber_RadiusY,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShapeEntity_EllipseArgs__storage_, radiusY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity_EllipseArgs class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity_EllipseArgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\007\000\004\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ShapeEntity)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShapeEntity_ShapeStyle

@implementation ShapeEntity_ShapeStyle

@dynamic hasFill, fill;
@dynamic hasStroke, stroke;
@dynamic strokeWidth;
@dynamic lineCap;
@dynamic lineJoin;
@dynamic miterLimit;
@dynamic lineDashI;
@dynamic lineDashIi;
@dynamic lineDashIii;

typedef struct ShapeEntity_ShapeStyle__storage_ {
  uint32_t _has_storage_[1];
  float strokeWidth;
  ShapeEntity_ShapeStyle_LineCap lineCap;
  ShapeEntity_ShapeStyle_LineJoin lineJoin;
  float miterLimit;
  float lineDashI;
  float lineDashIi;
  float lineDashIii;
  ShapeEntity_ShapeStyle_RGBAColor *fill;
  ShapeEntity_ShapeStyle_RGBAColor *stroke;
} ShapeEntity_ShapeStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fill",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_ShapeStyle_RGBAColor),
        .number = ShapeEntity_ShapeStyle_FieldNumber_Fill,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, fill),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stroke",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity_ShapeStyle_RGBAColor),
        .number = ShapeEntity_ShapeStyle_FieldNumber_Stroke,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, stroke),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "strokeWidth",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_FieldNumber_StrokeWidth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, strokeWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineCap",
        .dataTypeSpecific.enumDescFunc = ShapeEntity_ShapeStyle_LineCap_EnumDescriptor,
        .number = ShapeEntity_ShapeStyle_FieldNumber_LineCap,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, lineCap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lineJoin",
        .dataTypeSpecific.enumDescFunc = ShapeEntity_ShapeStyle_LineJoin_EnumDescriptor,
        .number = ShapeEntity_ShapeStyle_FieldNumber_LineJoin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, lineJoin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "miterLimit",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_FieldNumber_MiterLimit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, miterLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashI",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_FieldNumber_LineDashI,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, lineDashI),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashIi",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_FieldNumber_LineDashIi,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, lineDashIi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lineDashIii",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_FieldNumber_LineDashIii,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle__storage_, lineDashIii),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity_ShapeStyle class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity_ShapeStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\003\013\000\004\007\000\005\010\000\006\n\000\007\t\000\010\tA\000\t\tb\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ShapeEntity)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ShapeEntity_ShapeStyle_LineCap_RawValue(ShapeEntity_ShapeStyle *message) {
  GPBDescriptor *descriptor = [ShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_ShapeStyle_FieldNumber_LineCap];
  return GPBGetMessageInt32Field(message, field);
}

void SetShapeEntity_ShapeStyle_LineCap_RawValue(ShapeEntity_ShapeStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [ShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_ShapeStyle_FieldNumber_LineCap];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ShapeEntity_ShapeStyle_LineJoin_RawValue(ShapeEntity_ShapeStyle *message) {
  GPBDescriptor *descriptor = [ShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_ShapeStyle_FieldNumber_LineJoin];
  return GPBGetMessageInt32Field(message, field);
}

void SetShapeEntity_ShapeStyle_LineJoin_RawValue(ShapeEntity_ShapeStyle *message, int32_t value) {
  GPBDescriptor *descriptor = [ShapeEntity_ShapeStyle descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ShapeEntity_ShapeStyle_FieldNumber_LineJoin];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum ShapeEntity_ShapeStyle_LineCap

GPBEnumDescriptor *ShapeEntity_ShapeStyle_LineCap_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LineCapButt\000LineCapRound\000LineCapSquare\000";
    static const int32_t values[] = {
        ShapeEntity_ShapeStyle_LineCap_LineCapButt,
        ShapeEntity_ShapeStyle_LineCap_LineCapRound,
        ShapeEntity_ShapeStyle_LineCap_LineCapSquare,
    };
    static const char *extraTextFormatInfo = "\003\000\007\344\000\001\007\345\000\002\007\346\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShapeEntity_ShapeStyle_LineCap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShapeEntity_ShapeStyle_LineCap_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShapeEntity_ShapeStyle_LineCap_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShapeEntity_ShapeStyle_LineCap_LineCapButt:
    case ShapeEntity_ShapeStyle_LineCap_LineCapRound:
    case ShapeEntity_ShapeStyle_LineCap_LineCapSquare:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ShapeEntity_ShapeStyle_LineJoin

GPBEnumDescriptor *ShapeEntity_ShapeStyle_LineJoin_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LineJoinMiter\000LineJoinRound\000LineJoinBeve"
        "l\000";
    static const int32_t values[] = {
        ShapeEntity_ShapeStyle_LineJoin_LineJoinMiter,
        ShapeEntity_ShapeStyle_LineJoin_LineJoinRound,
        ShapeEntity_ShapeStyle_LineJoin_LineJoinBevel,
    };
    static const char *extraTextFormatInfo = "\003\000\010\345\000\001\010\345\000\002\010\345\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ShapeEntity_ShapeStyle_LineJoin)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ShapeEntity_ShapeStyle_LineJoin_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ShapeEntity_ShapeStyle_LineJoin_IsValidValue(int32_t value__) {
  switch (value__) {
    case ShapeEntity_ShapeStyle_LineJoin_LineJoinMiter:
    case ShapeEntity_ShapeStyle_LineJoin_LineJoinRound:
    case ShapeEntity_ShapeStyle_LineJoin_LineJoinBevel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ShapeEntity_ShapeStyle_RGBAColor

@implementation ShapeEntity_ShapeStyle_RGBAColor

@dynamic r;
@dynamic g;
@dynamic b;
@dynamic a;

typedef struct ShapeEntity_ShapeStyle_RGBAColor__storage_ {
  uint32_t _has_storage_[1];
  float r;
  float g;
  float b;
  float a;
} ShapeEntity_ShapeStyle_RGBAColor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "r",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_RGBAColor_FieldNumber_R,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle_RGBAColor__storage_, r),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "g",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_RGBAColor_FieldNumber_G,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle_RGBAColor__storage_, g),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "b",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_RGBAColor_FieldNumber_B,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle_RGBAColor__storage_, b),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "a",
        .dataTypeSpecific.className = NULL,
        .number = ShapeEntity_ShapeStyle_RGBAColor_FieldNumber_A,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShapeEntity_ShapeStyle_RGBAColor__storage_, a),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShapeEntity_ShapeStyle_RGBAColor class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShapeEntity_ShapeStyle_RGBAColor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ShapeEntity_ShapeStyle)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FrameEntity

@implementation FrameEntity

@dynamic alpha;
@dynamic hasLayout, layout;
@dynamic hasTransform, transform;
@dynamic clipPath;
@dynamic shapesArray, shapesArray_Count;

typedef struct FrameEntity__storage_ {
  uint32_t _has_storage_[1];
  float alpha;
  Layout *layout;
  Transform *transform;
  NSString *clipPath;
  NSMutableArray *shapesArray;
} FrameEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "alpha",
        .dataTypeSpecific.className = NULL,
        .number = FrameEntity_FieldNumber_Alpha,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FrameEntity__storage_, alpha),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "layout",
        .dataTypeSpecific.className = GPBStringifySymbol(Layout),
        .number = FrameEntity_FieldNumber_Layout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FrameEntity__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transform",
        .dataTypeSpecific.className = GPBStringifySymbol(Transform),
        .number = FrameEntity_FieldNumber_Transform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FrameEntity__storage_, transform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clipPath",
        .dataTypeSpecific.className = NULL,
        .number = FrameEntity_FieldNumber_ClipPath,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FrameEntity__storage_, clipPath),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shapesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ShapeEntity),
        .number = FrameEntity_FieldNumber_ShapesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FrameEntity__storage_, shapesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FrameEntity class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FrameEntity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MovieEntity

@implementation MovieEntity

@dynamic version;
@dynamic hasParams, params;
@dynamic images, images_Count;
@dynamic spritesArray, spritesArray_Count;

typedef struct MovieEntity__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  MovieParams *params;
  NSMutableDictionary *images;
  NSMutableArray *spritesArray;
} MovieEntity__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = MovieEntity_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MovieEntity__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "params",
        .dataTypeSpecific.className = GPBStringifySymbol(MovieParams),
        .number = MovieEntity_FieldNumber_Params,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MovieEntity__storage_, params),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "images",
        .dataTypeSpecific.className = NULL,
        .number = MovieEntity_FieldNumber_Images,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MovieEntity__storage_, images),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spritesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SpriteEntity),
        .number = MovieEntity_FieldNumber_SpritesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MovieEntity__storage_, spritesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MovieEntity class]
                                     rootClass:[ComOpensourceSvgaVideoRoot class]
                                          file:ComOpensourceSvgaVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MovieEntity__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
